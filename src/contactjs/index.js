function t(t,e,n,i){Object.defineProperty(t,e,{get:n,set:i,enumerable:!0,configurable:!0})}let e;var n;t(module.exports,"Direction",(()=>e)),t(module.exports,"Directions",(()=>i)),t(module.exports,"GestureState",(()=>s)),t(module.exports,"PointerManagerState",(()=>r)),t(module.exports,"PointerListenerState",(()=>l)),t(module.exports,"PointerState",(()=>d)),t(module.exports,"Geometry",(()=>p)),t(module.exports,"PointerListener",(()=>T)),t(module.exports,"GestureEvent",(()=>D)),t(module.exports,"Tap",(()=>f)),t(module.exports,"Press",(()=>G)),t(module.exports,"Pan",(()=>M)),t(module.exports,"TwoFingerPan",(()=>A)),t(module.exports,"Pinch",(()=>x)),t(module.exports,"Rotate",(()=>C)),(n=e||(e={})).None="0",n.Left="left",n.Right="right",n.Up="up",n.Down="down";const i=Object.freeze({Horizontal:[e.Left,e.Right],Vertical:[e.Up,e.Down],All:[e.Left,e.Right,e.Up,e.Down,e.None]});let s;var o;let r;var a;let l;var c;(o=s||(s={})).Inactive="inactive",o.Active="active",o.Blocked="blocked",(a=r||(r={})).NoPointer="nopointer",a.SinglePointer="singlepointer",a.DualPointer="dualpointer",(c=l||(l={})).NoActiveGesture="noactivegesture",c.ActiveGesture="activegesture";class h{constructor(t,e){this.x=t,this.y=e}}class u{constructor(t,n){this.startPoint=t,this.endPoint=n,this.direction=e.None,this.deltaX=this.endPoint.x-this.startPoint.x,this.deltaY=this.endPoint.y-this.startPoint.y,this.x=this.deltaX,this.y=this.deltaY,this.vectorLength=Math.sqrt(Math.pow(this.deltaX,2)+Math.pow(this.deltaY,2)),Math.abs(this.deltaX)>Math.abs(this.deltaY)?this.startPoint.x<this.endPoint.x?this.direction=e.Right:this.startPoint.x>this.endPoint.x&&(this.direction=e.Left):this.startPoint.y<this.endPoint.y?this.direction=e.Down:this.startPoint.y>this.endPoint.y&&(this.direction=e.Up)}}class p{static getVector(t,e){const n=new h(t.clientX,t.clientY),i=new h(e.clientX,e.clientY);return new u(n,i)}static getSpeed(t,e,n){let i=0;const s=(n-e)/1e3;return null!=t&&0!=s&&(i=t.vectorLength/s),i}static calculateRotationAngle(t,e){const n=new u(t.startPoint,e.startPoint),i=new u(t.endPoint,e.endPoint),s=new h(0,0),o=new u(n.startPoint,s),r=this.translatePoint(n.endPoint,o),a=new u(i.startPoint,s),l=this.translatePoint(i.endPoint,a),c=-1*this.calcAngleRad(r),p=l.x*Math.cos(c)-l.y*Math.sin(c),d=Math.round(l.x*Math.sin(c)+l.y*Math.cos(c));return 180*Math.atan2(d,p)/Math.PI}static calculateVectorAngle(t,e){let n=0;if(t.vectorLength>0&&e.vectorLength>0){const i=(t.x*e.x+t.y*e.y)/(t.vectorLength*e.vectorLength),s=Math.acos(i);n=this.rad2deg(s)}return n}static translatePoint(t,e){const n=t.x+e.x,i=t.y+e.y;return new h(n,i)}static calcAngleDegrees(t){let e=180*Math.atan2(t.y,t.x)/Math.PI;return e<0&&(e=360+e),e}static calcAngleRad(t){let e=Math.atan2(t.y,t.x);return e<0&&(e=2*Math.PI+e),e}static deg2rad(t){return Math.PI/180*t}static rad2deg(t){return t/(Math.PI/180)}static getCenter(t,e){const n=(t.x+e.x)/2,i=(t.y+e.y)/2;return new h(n,i)}static getCenterMovementVector(t,e){const n=this.getCenter(t.startPoint,e.startPoint),i=this.getCenter(t.endPoint,e.endPoint);return new u(n,i)}static calculateDistanceChange(t,e){const n=new u(t.startPoint,e.startPoint);return new u(t.endPoint,e.endPoint).vectorLength-n.vectorLength}static calculateAbsoluteDistanceChange(t,e){const n=this.calculateDistanceChange(t,e);return Math.abs(n)}static calculateRelativeDistanceChange(t,e){const n=new u(t.startPoint,e.startPoint);return new u(t.endPoint,e.endPoint).vectorLength/n.vectorLength}}let d;var v;(v=d||(d={})).Active="active",v.Removed="removed",v.Canceled="canceled";class m{constructor(t,e){this.options={DEBUG:!1,...e},this.DEBUG=this.options.DEBUG;const n=(new Date).getTime();this.pointerId=t.pointerId,this.vectorTimespan=this.options.vectorTimespan??100,this.initialPointerEvent=t,this.currentPointerEvent=t,this.recognizedEvents=[t],this.state=d.Active;const i=p.getVector(t,t),s={global:{startX:this.initialPointerEvent.clientX,startY:this.initialPointerEvent.clientY,vector:i,deltaX:0,deltaY:0,startTimestampUTC:n,startTimestamp:this.initialPointerEvent.timeStamp,currentTimestamp:this.initialPointerEvent.timeStamp,endTimestamp:null,maximumSpeed:0,currentSpeed:0,distance:0,maximumDistance:0,averageSpeed:0,finalSpeed:0,traveledDistance:0,hasBeenMoved:!1,duration:0},live:{duration:0,speed:0,vector:i,distance:0,isMoving:!1}};this.parameters=s}getTarget(){return this.initialPointerEvent.target}reset(){}onIdle(){const t=(new Date).getTime()-this.parameters.global.startTimestampUTC;this.parameters.global.duration=t}onPointerMove(t){this.parameters.global.hasBeenMoved=!0,this.parameters.live.isMoving=!0,this.update(t)}onPointerUp(t){this.parameters.global.finalSpeed=this.parameters.live.speed,this.parameters.live.speed=0,this.parameters.live.isMoving=!1,this.state=d.Removed,this.parameters.global.endTimestamp=t.timeStamp,this.update(t),!0===this.DEBUG&&console.log(`[PointerInput] pointerdown ended. pointerdown duration: ${this.parameters.global.duration}ms`)}onPointerLeave(t){this.onPointerUp(t)}onPointerCancel(t){this.update(t),this.parameters.live.speed=0,this.state=d.Canceled,this.parameters.live.isMoving=!1,this.parameters.global.endTimestamp=t.timeStamp,!0===this.DEBUG&&console.log(`[PointerInput] canceled, pointerdown duration:${this.parameters.global.duration}ms`)}update(t){this.currentPointerEvent=t,this.recognizedEvents.push(t);const e=this.getTimedPointerEvents(),n=p.getVector(e[0],e[1]);this.parameters.live.vector=n,this.parameters.live.distance=n.vectorLength,this.parameters.live.speed=p.getSpeed(n,e[0].timeStamp,e[1].timeStamp),this.parameters.live.speed>this.parameters.global.maximumSpeed&&(this.parameters.global.maximumSpeed=this.parameters.live.speed),this.parameters.global.currentTimestamp=t.timeStamp,this.parameters.global.duration=t.timeStamp-this.parameters.global.startTimestamp,this.parameters.global.deltaX=n.endPoint.x-this.parameters.global.startX,this.parameters.global.deltaY=n.endPoint.y-this.parameters.global.startY;const i=p.getVector(this.initialPointerEvent,this.currentPointerEvent);this.parameters.global.vector=i,this.parameters.global.distance=i.vectorLength,i.vectorLength>this.parameters.global.maximumDistance&&(this.parameters.global.maximumDistance=i.vectorLength),!0===this.DEBUG&&(console.log(`[PointerInput] current speed: ${this.parameters.live.speed}px/s`),console.log(`[PointerInput] pointerdown duration: ${this.parameters.global.duration}ms`),console.log(`[PointerInput] live vector length within vectorTimespan: ${this.parameters.live.vector.vectorLength}px`))}getTimedPointerEvents(){let t=this.initialPointerEvent;const e=this.recognizedEvents[this.recognizedEvents.length-1];let n=this.recognizedEvents.length-1,i=0;const s=e.timeStamp;for(;i<this.vectorTimespan&&(n-=1,!(n<0));)t=this.recognizedEvents[n],i=s-t.timeStamp;const o=[t,e];return this.recognizedEvents=this.recognizedEvents.slice(-20),o}}class g{constructor(t){this.pointer=t,this.parameters=t.parameters}getTarget(){return this.pointer.initialPointerEvent.target}getCurrentPointerEvent(){return this.pointer.currentPointerEvent}getCurrentDirection(){return this.parameters.live.vector.direction}onIdle(){}onPointerMove(t){}onPointerUp(t){}onPointerLeave(t){}onPointerCancel(t){}}const P=globalThis.window;let E;E=P?.CustomEvent?P.CustomEvent:class extends Event{constructor(t,e){super(t,e),this.detail=e?.detail}initCustomEvent(){throw new Error("Unsupported deprecated method")}};class D extends E{}class b{constructor(t,e){this.state=s.Inactive,this.validPointerManagerState=null,this.validPointerInputConstructor=g,this.domElement=t,this.initialPointerEvent=null,this.initialParameters=null,this.activeStateParameters=null,this.options={bubbles:!0,blocks:[],supportedDirections:[],supportedButtons:[],DEBUG:!1,...e},this.DEBUG=this.options.DEBUG}getEmptyGestureParameters(){return{global:{min:{},max:{},boolean:{}},live:{min:{},max:{},boolean:{}}}}getGestureParameters(){let t;if(this.state==s.Active?(t=this.activeStateParameters,1==this.DEBUG&&(console.log(`[${this.eventBaseName}] validating using activeStateParameters`),console.log(t))):(1==this.DEBUG&&console.log(`[${this.eventBaseName}] validating using initialParameters`),t=this.initialParameters),null==t)throw new Error("[Gesture] no gesture parameters found. Do not call .getGestureParameters on abstract class Gesture");return t}validateGestureParameters(t){const e=this.getGestureParameters();let n,i=!0;for(n in e){const s=e[n],o=t.parameters[n];let r;for(r in s){const t=s[r];let e;for(e in t){const s=t[e],a=o[e];if(1==this.DEBUG&&console.log(`[${this.eventBaseName}] validating ${n} ${r}: required: ${s}, pointer: ${a}`),"boolean"==typeof s&&"boolean"==typeof a?i=this.validateBooleanParameter(s,a):"number"==typeof s&&"number"==typeof a&&(i=this.validateMinMaxParameter(s,a,r)),0==i)return 1==this.DEBUG&&console.log(`[${this.eventBaseName}] invalidated `),!1}}}return!0}validateBooleanParameter(t,e){return null==t||(t==e?(1==this.DEBUG&&console.log(`validated: required value: ${t}, current value: ${e}`),!0):(1==this.DEBUG&&console.log(`dismissing ${this.eventBaseName}: required value: ${t}, current value: ${e}`),!1))}validateMinMaxParameter(t,e,n){if("min"==n){if(e>=t)return!0}else if("max"==n&&e<=t)return!0;return!1}validateDirection(t){const e=t.getCurrentDirection();return!(this.options.supportedDirections.length&&!this.options.supportedDirections.includes(e))||(1==this.DEBUG&&console.log(`[Gestures] dismissing ${this.eventBaseName}: supported directions: ${this.options.supportedDirections}, current direction: ${e}`),!1)}validateGestureState(){return this.state!=s.Blocked}validatePointerManagerState(t){return t.state==this.validPointerManagerState||(1==this.DEBUG&&console.log(`[Gesture] PointerManagerState invalidated ${this.eventBaseName}: ${t.state}`),!1)}validatePointerInputConstructor(t){return t instanceof this.validPointerInputConstructor||(1==this.DEBUG&&console.log(`[Gesture] PointerInputConstructor invalidated ${this.eventBaseName}: ${this.validPointerInputConstructor}`),!1)}validate(t){let e=this.validateGestureState();1==e&&(e=this.validatePointerManagerState(t));const n=t.activePointerInput;return 1==e&&null!=n&&(e=this.validatePointerInputConstructor(n),1==e&&(e=this.validateDirection(n)),1==e&&(e=this.validateGestureParameters(n))),e}recognize(t){const e=this.validate(t);1==e&&this.state==s.Inactive&&this.onStart(t),1==e&&this.state==s.Active?(null==this.initialPointerEvent&&this.setInitialPointerEvent(t),this.emit(t)):this.state==s.Active&&0==e?this.onEnd(t):1==this.DEBUG&&console.log(`not firing event ${this.eventBaseName}. No SinglePointerInput found`)}getPointerInput(t){if(1==t.hasPointersOnSurface()&&t.activePointerInput instanceof this.validPointerInputConstructor)return t.activePointerInput;if(t.lastRemovedPointer instanceof m){const e=t.getlastRemovedPointerInput();if(e instanceof this.validPointerInputConstructor)return e}return null}setInitialPointerEvent(t){const e=this.getPointerInput(t);if(e instanceof this.validPointerInputConstructor){const t=e.getCurrentPointerEvent();this.initialPointerEvent=t}}emit(t,n){n=n||this.eventBaseName,!0===this.DEBUG&&console.log(`[Gestures] detected and firing event ${n}`);const i=this.getPointerInput(t);if(null!=i){const s=i.getTarget();if(s instanceof EventTarget){const o=this.getEventData(i,t),r={detail:o,bubbles:this.options.bubbles};!0===this.DEBUG&&console.log(r);const a=new D(n,r);1==r.bubbles?s.dispatchEvent(a):this.domElement.dispatchEvent(a);const l=o.live.direction;if(1==!!this.options.supportedDirections&&l!=e.None&&(n==this.eventBaseName||"swipe"==n))for(let t=0;t<this.options.supportedDirections.length;t++){const e=this.options.supportedDirections[t];if(e==l){const t=n+e;1==this.DEBUG&&console.log(`[Gestures] detected and firing event ${t}`);const i=new D(t,r);1==r.bubbles?s.dispatchEvent(i):this.domElement.dispatchEvent(i)}}}}}onStart(t){this.blockGestures(),this.state=s.Active,this.setInitialPointerEvent(t);const e=`${this.eventBaseName}start`;this.emit(t,e)}onEnd(t){this.unblockGestures(),1==this.DEBUG&&console.log(`[${this.eventBaseName}] ended. Setting ${this.eventBaseName}.state = ${s.Inactive}`),this.state=s.Inactive;const e=`${this.eventBaseName}end`;this.emit(t,e)}onTouchStart(t){}onTouchMove(t){}onTouchEnd(t){}onTouchCancel(t){}block(t){-1==this.options.blocks.indexOf(t)&&this.options.blocks.push(t)}unblock(t){-1!=this.options.blocks.indexOf(t)&&this.options.blocks.splice(this.options.blocks.indexOf(t),1)}blockGestures(){for(let t=0;t<this.options.blocks.length;t++){const e=this.options.blocks[t];e.state==s.Inactive&&(0==this.DEBUG&&console.log(`[Gesture] blocking ${e.eventBaseName}`),e.state=s.Blocked)}}unblockGestures(){for(let t=0;t<this.options.blocks.length;t++){this.options.blocks[t].state=s.Inactive}}getEventData(t,e){throw new Error("Gesture subclasses require a getEventData method()")}}class I extends b{constructor(t,e){super(t,e),this.initialPointerEvent=null,this.validPointerManagerState=r.SinglePointer;const n=this.getEmptyGestureParameters();this.initialParameters={...n},this.activeStateParameters=JSON.parse(JSON.stringify({...n}))}getEventData(t,e){const n=t.parameters.live,i=t.parameters.live;let s=n.vector,o=n.duration;if(null!=this.initialPointerEvent){const e=new h(this.initialPointerEvent.clientX,this.initialPointerEvent.clientY),n=new h(t.pointer.currentPointerEvent.clientX,t.pointer.currentPointerEvent.clientY);s=new u(e,n),o=t.pointer.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp}return{recognizer:this,global:{deltaX:s.x,deltaY:s.y,distance:s.vectorLength,speedX:s.x/o,speedY:s.y/o,speed:s.vectorLength/o,direction:s.direction,scale:1,rotation:0,center:{x:n.vector.endPoint.x,y:n.vector.endPoint.y},srcEvent:t.pointer.currentPointerEvent},live:{deltaX:i.vector.x,deltaY:i.vector.y,distance:i.vector.vectorLength,speedX:i.vector.x/t.pointer.vectorTimespan,speedY:i.vector.y/t.pointer.vectorTimespan,speed:i.speed,direction:i.vector.direction,scale:1,rotation:0,center:{x:i.vector.endPoint.x,y:i.vector.endPoint.y},srcEvent:t.pointer.currentPointerEvent},pointerManager:e}}validateButton(t){if(this.options.supportedButtons.length>0){const e=t.activePointerInput,n=t.lastRemovedPointer;let i=null;if(null!=e?i=e.getCurrentPointerEvent():null!=n&&(i=n.currentPointerEvent),null!=i&&"mouse"==i.pointerType&&-1==this.options.supportedButtons.indexOf(i.buttons))return 1==this.DEBUG&&console.log(`dismissing ${this.eventBaseName}: supportedButtons: ${this.options.supportedButtons.toString()}, poinerEvent.buttons: ${i.buttons}`),!1}return!0}validate(t){let e=this.validateButton(t);return 1==e&&(e=super.validate(t)),e}}class f extends I{constructor(t,e){super(t,e),this.validPointerManagerState=r.NoPointer,this.eventBaseName="tap";let n=499,i=30,s=30;e&&("maxDuration"in e&&(n=e.maxDuration),"maxDistance"in e&&(i=e.maxDistance,s=e.maxDistance)),this.initialParameters.global.max.duration=n,this.initialParameters.live.max.distance=i,this.initialParameters.global.max.distance=s}validateButton(t){if(this.options.supportedButtons.length>0){const e=t.lastRemovedPointer;if(null!=e){const t=e.currentPointerEvent;if("mouse"==t.pointerType&&-1==this.options.supportedButtons.indexOf(t.button))return 1==this.DEBUG&&console.log(`dismissing ${this.eventBaseName}: supportedButtons: ${this.options.supportedButtons.toString()}, poinerEvent.button: ${t.button}`),!1}}return!0}validate(t){let e=this.validateGestureState();if(1==e&&(e=this.validatePointerManagerState(t)),1==e&&(e=this.validateButton(t)),!0===e){if(1!=t.lastInputSessionPointerCount)return!1;{const n=t.getlastRemovedPointerInput();e=n instanceof g&&this.validateGestureParameters(n)}}return e}onStart(t){this.setInitialPointerEvent(t),this.emit(t)}}class G extends I{static minDuration=500;constructor(t,e){super(t,e),this.eventBaseName="press";let n=500,i=10,s=20;e&&("minDuration"in e&&(n=e.minDuration),"maxDistance"in e&&(s=e.maxDistance,i=e.maxDistance)),this.initialParameters.global.min.duration=n,this.initialParameters.global.max.distance=i,this.initialParameters.global.max.maximumDistance=s,this.hasBeenEmitted=!1}recognize(t){const e=this.validate(t),n=this.getPointerInput(t),i=this.initialParameters.global.min.duration||G.minDuration;if(n instanceof g)if(1==e&&0==this.hasBeenEmitted)this.setInitialPointerEvent(t),this.emit(t),this.hasBeenEmitted=!0,this.state=s.Active,this.blockGestures();else if(0==e&&1==this.hasBeenEmitted)this.onEnd(t),this.state=s.Inactive,this.hasBeenEmitted=!1;else{const t=n.parameters.global.duration;1==this.hasBeenEmitted&&t<=i&&(this.hasBeenEmitted=!1)}null==n&&(this.hasBeenEmitted=!1)}}class M extends I{constructor(t,e){super(t,e),this.validPointerManagerState=r.SinglePointer,this.eventBaseName="pan",this.initialParameters.global.min.duration=0,this.initialParameters.live.min.distance=10,this.initialParameters.global.boolean.hasBeenMoved=!0,this.swipeFinalSpeed=600,this.isSwipe=!1,this.options.supportedDirections=e?.supportedDirections??i.All,this.initialSupportedDirections=this.options.supportedDirections}validate(t){this.state==s.Active&&(this.options.supportedDirections=i.All);return super.validate(t)}onStart(t){this.isSwipe=!1,super.onStart(t)}onEnd(t){const n=t.getlastRemovedPointerInput();n instanceof g&&(this.swipeFinalSpeed<n.parameters.global.finalSpeed&&n.parameters.live.vector.direction!=e.None?(this.isSwipe=!0,this.emit(t,"swipe")):1==this.DEBUG&&(n.parameters.global.finalSpeed<this.swipeFinalSpeed?console.log(`[Pan] dismissing swipe. Final speed: ${n.parameters.global.finalSpeed} < ${this.swipeFinalSpeed}`):console.log(`[Pan] dismissing swipe. Direction: ${n.parameters.live.vector.direction}`))),super.onEnd(t),this.options.supportedDirections=this.initialSupportedDirections}onTouchMove(t){this.state==s.Active&&(1==this.DEBUG&&console.log("[Pan] preventing touchmove default"),t.stopPropagation())}}class B{constructor(t,e){this.pointerIds=new Set([t.pointerId,e.pointerId]),this.startTimestamp=(new Date).getTime(),this.pointerMap={},this.pointerMap[t.pointerId]=t,this.pointerMap[e.pointerId]=e,this.pointer_1=t,this.pointer_2=e,this.initialPointerEvent=t.initialPointerEvent,this.currentPointerEvent=t.initialPointerEvent;const n=this.pointer_1.parameters.global.vector,i=this.pointer_2.parameters.global.vector,s={duration:0,center:p.getCenter(n.startPoint,i.startPoint),centerHasBeenMoved:!1,centerMovementDistance:0,centerMovementVector:p.getCenterMovementVector(n,i),absolutePointerDistanceChange:0,relativePointerDistanceChange:0,rotationAngle:0,absoluteRotationAngle:0,vectorAngle:0,absoluteVectorAngle:0},o=this.pointer_1.parameters.live.vector,r=this.pointer_2.parameters.live.vector,a={global:s,live:{center:p.getCenter(o.startPoint,r.startPoint),centerIsMoving:!1,centerMovementDistance:0,centerMovementVector:p.getCenterMovementVector(o,r),absolutePointerDistanceChange:0,relativePointerDistanceChange:0,rotationAngle:0,absoluteRotationAngle:0,vectorAngle:0,absoluteVectorAngle:0}};this.parameters=a}removePointer(t){if(t==this.pointer_1.pointerId)return this.pointer_2;if(t==this.pointer_2.pointerId)return this.pointer_1;throw new Error(`[DualPointerInput] cannot remove Pointer #${t}. The pointer is not part of this DualPointerInput`)}getTarget(){return this.initialPointerEvent.target}update(t){t instanceof PointerEvent&&(this.currentPointerEvent=t);const e=(new Date).getTime();this.parameters.global.duration=e-this.startTimestamp;const n=this.pointer_1.parameters.global.vector,i=this.pointer_2.parameters.global.vector,s=p.getCenter(n.startPoint,i.startPoint),o=p.getCenterMovementVector(n,i),r=p.calculateAbsoluteDistanceChange(n,i),a=p.calculateRelativeDistanceChange(n,i),l=p.calculateRotationAngle(n,i),c=p.calculateVectorAngle(n,i);this.parameters.global.center=s,this.parameters.global.centerMovementVector=o,this.parameters.global.centerMovementDistance=o.vectorLength,this.parameters.global.absolutePointerDistanceChange=r,this.parameters.global.relativePointerDistanceChange=a,this.parameters.global.rotationAngle=l,this.parameters.global.absoluteRotationAngle=Math.abs(l),this.parameters.global.vectorAngle=c,this.parameters.global.absoluteVectorAngle=Math.abs(c);const h=this.pointer_1.parameters.live.vector,u=this.pointer_2.parameters.live.vector,d=p.getCenter(h.startPoint,u.startPoint),v=p.getCenterMovementVector(h,u),m=p.calculateAbsoluteDistanceChange(h,u),g=p.calculateRelativeDistanceChange(h,u),P=p.calculateRotationAngle(h,u),E=p.calculateVectorAngle(h,u);v.vectorLength>0?(this.parameters.live.centerIsMoving=!0,this.parameters.global.centerHasBeenMoved=!0):this.parameters.live.centerIsMoving=!1,this.parameters.live.center=d,this.parameters.live.centerMovementDistance=v.vectorLength,this.parameters.live.centerMovementVector=v,this.parameters.live.absolutePointerDistanceChange=m,this.parameters.live.relativePointerDistanceChange=g,this.parameters.live.rotationAngle=P,this.parameters.live.absoluteRotationAngle=Math.abs(P),this.parameters.live.vectorAngle=E,this.parameters.live.absoluteVectorAngle=Math.abs(E)}onPointerMove(t){this.update(t)}onPointerUp(t){this.update(t)}onPointerLeave(t){this.update(t)}onPointerCancel(t){this.update(t)}onIdle(){this.update()}getCurrentDirection(){return this.parameters.live.centerMovementVector.direction}getCurrentPointerEvent(){return this.currentPointerEvent}}class S extends b{constructor(t,e){super(t,e),this.initialPointerEvent_1=null,this.initialPointerEvent_2=null,this.validPointerManagerState=r.DualPointer,this.validPointerInputConstructor=B;const n=this.getEmptyGestureParameters();this.initialParameters={...n},this.activeStateParameters=JSON.parse(JSON.stringify({...n}))}getEventData(t,e){const n=t.parameters.global,i=t.parameters.live;return{recognizer:this,global:{deltaX:n.centerMovementVector.x,deltaY:n.centerMovementVector.y,distance:n.centerMovementDistance,speedX:n.centerMovementVector.x/n.duration,speedY:n.centerMovementVector.y/n.duration,speed:n.centerMovementVector.vectorLength/n.duration,direction:n.centerMovementVector.direction,scale:n.relativePointerDistanceChange,rotation:n.rotationAngle,center:n.center,srcEvent:t.currentPointerEvent},live:{deltaX:i.centerMovementVector.x,deltaY:i.centerMovementVector.y,distance:i.centerMovementDistance,speedX:i.centerMovementVector.x/n.duration,speedY:i.centerMovementVector.y/n.duration,speed:i.centerMovementVector.vectorLength/n.duration,direction:i.centerMovementVector.direction,scale:i.relativePointerDistanceChange,rotation:i.rotationAngle,center:{x:i.centerMovementVector.startPoint.x,y:i.centerMovementVector.startPoint.y},srcEvent:t.currentPointerEvent},pointerManager:e}}}class x extends S{constructor(t,e){super(t,e),this.eventBaseName="pinch",this.initialParameters.live.min.centerMovementDistance=0,this.initialParameters.live.max.centerMovementDistance=50,this.initialParameters.live.min.absolutePointerDistanceChange=5,this.initialParameters.live.max.absoluteRotationAngle=20,this.initialParameters.live.min.absoluteVectorAngle=10}}class C extends S{constructor(t,e){super(t,e),this.eventBaseName="rotate",this.initialParameters.live.min.centerMovementDistance=0,this.initialParameters.live.max.centerMovementDistance=50,this.initialParameters.live.max.absolutePointerDistanceChange=50,this.initialParameters.live.min.absoluteRotationAngle=5,this.activeStateParameters.live.min.absoluteRotationAngle=0}}class A extends S{constructor(t,e){super(t,e),this.eventBaseName="twofingerpan",this.initialParameters.live.min.centerMovementDistance=10,this.initialParameters.live.max.absolutePointerDistanceChange=50,this.initialParameters.live.max.absoluteVectorAngle=150,this.activeStateParameters.live.min.centerMovementDistance=0}}class w{constructor(t){t=t||{},this.options={DEBUG:!1,...t},this.DEBUG=this.options.DEBUG,this.state=r.NoPointer,this.activePointerInput=null,this.lastRemovedPointer=null,this.lastInputSessionPointerCount=0,this.pointerAllocation={},this.unusedPointers={},this.onSurfacePointers={}}addPointer(t){1==this.DEBUG&&console.log(`[PointerManager] adding Pointer #${t.pointerId.toString()}`);const e={DEBUG:this.DEBUG},n=new m(t,e);this.onSurfacePointers[n.pointerId]=n,null==this.activePointerInput?this.setActiveSinglePointerInput(n):this.activePointerInput instanceof g?this.setActiveDualPointerInput(this.activePointerInput.pointer,n):this.activePointerInput instanceof B&&(this.unusedPointers[n.pointerId]=n),this.lastInputSessionPointerCount=this.currentPointerCount()}removePointer(t){1==this.DEBUG&&(console.log(`[PointerManager] starting to remove Pointer #${t}`),console.log(`[PointerManager] state: ${this.state}`));const e=this.onSurfacePointers[t];if(this.lastRemovedPointer=e,delete this.onSurfacePointers[t],t in this.unusedPointers&&delete this.unusedPointers[t],this.activePointerInput instanceof B){if(this.activePointerInput.pointerIds.has(t)){1==this.DEBUG&&console.log(`[PointerManager] removing Pointer #${t} from DualPointerInput`);const e=this.activePointerInput.removePointer(t);this.activePointerInput=null;const n=this.getUnusedPointer();n instanceof m?this.setActiveDualPointerInput(e,n):this.setActiveSinglePointerInput(e)}}else if(this.activePointerInput instanceof g){if(1==this.DEBUG&&console.log(`[PointerManager] removing Pointer #${t} from SinglePointerInput`),this.activePointerInput=null,this.state=r.NoPointer,Object.keys(this.unusedPointers).length>0)throw this.unusedPointers={},new Error("[PointerManager] found unused Pointers although there should not be any");if(Object.keys(this.onSurfacePointers).length>0)throw this.onSurfacePointers={},new Error("[PointerManager] found onSurfacePointers although there should not be any")}1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}setActiveSinglePointerInput(t){t.reset();const e=new g(t);this.activePointerInput=e,this.pointerAllocation[t.pointerId]=e,delete this.unusedPointers[t.pointerId],this.state=r.SinglePointer,1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}setActiveDualPointerInput(t,e){t.reset(),e.reset();const n=new B(t,e);this.activePointerInput=n,this.pointerAllocation[t.pointerId]=n,this.pointerAllocation[e.pointerId]=n,delete this.unusedPointers[t.pointerId],delete this.unusedPointers[e.pointerId],this.state=r.DualPointer,1==this.DEBUG&&console.log(`[PointerManager] state: ${this.state}`)}hasPointersOnSurface(){return Object.keys(this.onSurfacePointers).length>0}currentPointerCount(){return Object.keys(this.onSurfacePointers).length}getUnusedPointer(){if(Object.keys(this.unusedPointers).length>0){return Object.values(this.unusedPointers)[0]}return null}getPointerFromId(t){return t in this.onSurfacePointers?this.onSurfacePointers[t]:null}getlastRemovedPointerInput(){return this.lastRemovedPointer instanceof m?this.pointerAllocation[this.lastRemovedPointer.pointerId]:null}onIdle(){for(const t in this.onSurfacePointers){this.onSurfacePointers[t].onIdle()}this.activePointerInput?.onIdle()}onPointerMove(t){const e=this.getPointerFromId(t.pointerId);e instanceof m&&e.onPointerMove(t),this.activePointerInput?.onPointerMove(t)}onPointerUp(t){1==this.DEBUG&&console.log("[PointerManager] pointerup detected");const e=this.getPointerFromId(t.pointerId);e instanceof m&&e.onPointerUp(t),this.activePointerInput?.onPointerUp(t),this.removePointer(t.pointerId)}onPointerCancel(t){1==this.DEBUG&&console.log("[PointerManager] pointercancel detected");const e=this.getPointerFromId(t.pointerId);e instanceof m&&e.onPointerCancel(t),this.activePointerInput?.onPointerCancel(t),this.removePointer(t.pointerId)}}const U=[f,G,M,x,C,A];class T{constructor(t,e){this.state=l.NoActiveGesture,this.activeGestures=[],this.hadActiveGestureDuringCurrentContact=!1,this.gestureEventHandlers={},this.lastRecognitionTimestamp=null,this.idleRecognitionIntervalId=null,this.pointerEventHandlers={},this.touchEventHandlers={},e=e||{},this.options={DEBUG:!1,DEBUG_GESTURES:!1,DEBUG_POINTERMANAGER:!1,bubbles:!0,handleTouchEvents:!0,consecutiveGestures:!0,simultaneousGestures:!0,supportedGestures:[],...e},this.DEBUG=this.options.DEBUG;const n=(e.supportedGestures??U).map((e=>{if("function"==typeof e){const n={bubbles:this.options.bubbles,DEBUG:this.options.DEBUG_GESTURES};return new e(t,n)}if("object"==typeof e)return e;throw new Error("unsupported gesture type: "+typeof e)}));this.supportedGestures=n,this.domElement=t;const i={DEBUG:this.options.DEBUG_POINTERMANAGER};this.pointerManager=new w(i),this.addPointerEventListeners(),this.addTouchEventListeners()}addPointerEventListeners(){const t=this.domElement,e=this.onPointerDown.bind(this),n=this.onPointerMove.bind(this),i=this.onPointerUp.bind(this),s=this.onPointerCancel.bind(this);t.addEventListener("pointerdown",e,{passive:!0}),t.addEventListener("pointermove",n,{passive:!0}),t.addEventListener("pointerup",i,{passive:!0}),t.addEventListener("pointercancel",s,{passive:!0}),this.pointerEventHandlers={pointerdown:e,pointermove:n,pointerup:i,pointercancel:s}}onPointerDown(t){1==this.DEBUG&&console.log("[PointerListener] pointerdown event detected"),(t.target||this.domElement).setPointerCapture(t.pointerId),this.pointerManager.addPointer(t),this.options.pointerdown?.(t,this),null!=this.idleRecognitionIntervalId&&this.clearIdleRecognitionInterval(),this.idleRecognitionIntervalId=setInterval((()=>{this.onIdle()}),100)}onPointerMove(t){1==this.pointerManager.hasPointersOnSurface()&&(this.pointerManager.onPointerMove(t),this.recognizeGestures(),this.options.pointermove?.(t,this))}onPointerUp(t){1==this.DEBUG&&console.log("[PointerListener] pointerup event detected"),this.domElement.releasePointerCapture(t.pointerId),1==this.pointerManager.hasPointersOnSurface()&&(this.pointerManager.onPointerUp(t),this.recognizeGestures(),this.options.pointerup?.(t,this)),this.clearIdleRecognitionInterval()}onPointerCancel(t){this.domElement.releasePointerCapture(t.pointerId),1==this.DEBUG&&console.log("[PointerListener] pointercancel detected"),this.pointerManager.onPointerCancel(t),this.recognizeGestures(),this.clearIdleRecognitionInterval(),this.options.pointercancel?.(t,this)}removePointerEventListeners(){for(const t in this.pointerEventHandlers){const e=this.pointerEventHandlers[t];this.domElement.removeEventListener(t,e)}}addTouchEventListeners(){if(1==this.options.handleTouchEvents){const t=this.onTouchMove.bind(this);this.domElement.addEventListener("touchmove",t),this.touchEventHandlers.touchmove=t}}removeTouchEventListeners(){for(const t in this.touchEventHandlers){const e=this.touchEventHandlers[t];this.domElement.removeEventListener(t,e)}}onTouchMove(t){for(let e=0;e<this.supportedGestures.length;e++){this.supportedGestures[e].onTouchMove(t)}}onIdle(){if(0==this.pointerManager.hasPointersOnSurface())this.clearIdleRecognitionInterval();else{const t=(new Date).getTime();let e=null;null!=this.lastRecognitionTimestamp&&(e=t-this.lastRecognitionTimestamp),(null==e||e>100)&&(this.pointerManager.onIdle(),1==this.DEBUG&&console.log("[PointerListener] onIdle - running idle recognition"),this.recognizeGestures())}}clearIdleRecognitionInterval(){null!=this.idleRecognitionIntervalId&&(clearInterval(this.idleRecognitionIntervalId),this.idleRecognitionIntervalId=null)}recognizeGestures(){this.lastRecognitionTimestamp=(new Date).getTime();let t=this.supportedGestures;0==this.options.simultaneousGestures&&this.state==l.ActiveGesture||0==this.options.consecutiveGestures&&this.state==l.ActiveGesture?t=[this.activeGestures[0]]:0==this.options.consecutiveGestures&&this.state==l.NoActiveGesture&&1==this.hadActiveGestureDuringCurrentContact&&1==this.pointerManager.hasPointersOnSurface()&&(t=[]);for(let e=0;e<t.length;e++){const n=t[e];if(n.recognize(this.pointerManager),this.updateActiveGestures(n),0==this.options.simultaneousGestures&&this.state==l.ActiveGesture)break}1==this.DEBUG&&console.log(`[PointerListener] hadActiveGestureDuringCurrentContact: ${this.hadActiveGestureDuringCurrentContact}`),0==this.pointerManager.hasPointersOnSurface()&&(this.hadActiveGestureDuringCurrentContact=!1)}updateActiveGestures(t){if(t.state==s.Active)this.hadActiveGestureDuringCurrentContact=!0,this.activeGestures.indexOf(t)<0&&this.activeGestures.push(t);else{const e=this.activeGestures.indexOf(t);e>=0&&this.activeGestures.splice(e,1)}this.activeGestures.length>0?this.state=l.ActiveGesture:this.state=l.NoActiveGesture}parseEventsString(t){return t.trim().split(/\s+/g)}on(t,e){const n=this.parseEventsString(t);for(let t=0;t<n.length;t++){const i=n[t];i in this.gestureEventHandlers||(this.gestureEventHandlers[i]=[]),-1==this.gestureEventHandlers[i].indexOf(e)&&this.gestureEventHandlers[i].push(e),this.domElement.addEventListener(i,e,{capture:!1,passive:!0})}}off(t,e){const n=this.parseEventsString(t);1==this.DEBUG&&(console.log(`[PointerListener] turning off events: ${t}`),console.log(this.gestureEventHandlers));for(let t=0;t<n.length;t++){const i=n[t];if(i in this.gestureEventHandlers){const t=this.gestureEventHandlers[i],n=t.indexOf(e);1==this.DEBUG&&console.log(`[PointerListener] turning off ${i}. Index on handlerList: ${n}`),n>=0&&(t.splice(n,1),this.gestureEventHandlers[i]=t),this.domElement.removeEventListener(i,e,!1)}}}destroy(){for(const t in this.gestureEventHandlers){const e=this.gestureEventHandlers[t];for(let n=0;n<e.length;n++){const i=e[n];this.domElement.removeEventListener(t,i)}delete this.gestureEventHandlers[t]}this.removePointerEventListeners(),this.removeTouchEventListeners()}}
//# sourceMappingURL=index.js.map
